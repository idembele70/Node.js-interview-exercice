ğŸ”¥ Parfait, tu passes clairement dans la **zone intermÃ©diaire+++++** â†’ lÃ  on va attaquer des exercices qui touchent :

* Validation avancÃ©e avec **Zod**
* Usage de **Lodash** dans des cas plus tricky
* Middlewares Express plus complexes
* Gestion des erreurs et des promesses concurrentes
* Optimisation de code serveur

---

## **QCM (5 questions)**

**1. Dans Express, quel est lâ€™ordre correct de traitement des middlewares et routes ?**
A. Middleware global â†’ Route spÃ©cifique â†’ Middleware dâ€™erreur
B. Route spÃ©cifique â†’ Middleware global â†’ Middleware dâ€™erreur
C. Middleware dâ€™erreur â†’ Middleware global â†’ Route spÃ©cifique
D. Aucun ordre prÃ©cis

---

**2. Concernant `Promise.allSettled()` vs `Promise.all()` :**
A. `Promise.allSettled()` renvoie toujours toutes les promesses, rÃ©ussies ou Ã©chouÃ©es.
B. `Promise.all()` rejette immÃ©diatement si une promesse Ã©choue.
C. `Promise.allSettled()` est plus adaptÃ© pour du parallÃ©lisme tolÃ©rant aux erreurs.
D. `Promise.all()` et `Promise.allSettled()` se comportent identiquement.

---

**3. Avec Lodash, quelle mÃ©thode est adaptÃ©e pour supprimer toutes les valeurs `null` ou `undefined` dâ€™un objet profondÃ©ment imbriquÃ© ?**
A. `_.omitBy`
B. `_.pickBy`
C. `_.compact`
D. `_.cleanDeep` (nâ€™existe pas dans Lodash)

---

**4. Si on veut crÃ©er un schÃ©ma Zod qui valide :**

* `name` = string non vide
* `age` = nombre entier positif
* `email` = string format email
  Quel est le schÃ©ma correct ?
  A. `z.object({ name: z.string(), age: z.number(), email: z.string() })`
  B. `z.object({ name: z.string().min(1), age: z.number().int().positive(), email: z.string().email() })`
  C. `z.object({ name: z.string().optional(), age: z.number().min(0), email: z.string().min(1) })`
  D. `z.object({ name: z.string().nonempty(), age: z.number().int().positive(), email: z.string().email() })`

---

**5. Dans Express, si un middleware appelle `next(err)` au lieu de `next()`, que se passe-t-il ?**
A. La requÃªte est interrompue et Express envoie un 500 automatiquement.
B. Express saute les middlewares normaux et appelle directement les middlewares dâ€™erreurs (`(err, req, res, next)`).
C. La requÃªte est relancÃ©e depuis le dÃ©but de la pile.
D. Le serveur crash si aucun middleware dâ€™erreur nâ€™est dÃ©fini.

---

---

## **Exercices de Code (5 exercices)**

**6. Middleware avancÃ© de validation dâ€™`Authorization` Bearer Token**
Ã‰cris un middleware qui :

* VÃ©rifie que lâ€™en-tÃªte `Authorization` existe
* VÃ©rifie quâ€™il commence par `Bearer `
* RÃ©cupÃ¨re le token et lâ€™ajoute dans `req.token`
* Sinon, renvoie un `401 Unauthorized`

---

**7. Logger en JSON dans un fichier**
Ã‰cris une fonction `logRequestToFile(req)` qui enregistre dans un fichier `access.log` un objet JSON avec :

* mÃ©thode (`method`)
* url (`url`)
* ip (`ip`)
* date (`date`) en ISO

---

**8. Regrouper et compter avec Lodash**
Ã‰cris une fonction `countUsersByRole(users)` qui, Ã  partir dâ€™un tableau comme :

```js
[
  { name: "Alice", role: "admin" },
  { name: "Bob", role: "user" },
  { name: "Clara", role: "admin" }
]
```

Retourne :

```js
{ admin: 2, user: 1 }
```

---

**9. Route Express PUT /tasks/\:id**
Ã‰cris une route qui permet de mettre Ã  jour la `title` dâ€™une tÃ¢che dans un tableau en mÃ©moire :

```js
let tasks = [
  { id: 1, title: "Buy milk" },
  { id: 2, title: "Read book" }
];
```

* Si `id` nâ€™existe pas â†’ `404`
* Si `title` est manquant â†’ `400`
* Sinon, renvoyer la tÃ¢che mise Ã  jour avec `200`

---

**10. ExÃ©cution concurrente avec rÃ©cupÃ©ration partielle**
Ã‰cris une fonction `fetchPosts(ids)` qui :

* Fait un `fetch` en parallÃ¨le sur lâ€™API `https://jsonplaceholder.typicode.com/posts/:id`
* Ignore les erreurs (remplacer par `null`)
* Retourne un tableau avec les rÃ©sultats ou `null` si Ã©chec

---

ğŸ‘‰ LÃ , on est dÃ©jÃ  Ã  un **niveau intermÃ©diaire+++++ solide**, proche des entretiens **backend mid-level**.
Veux-tu que je prÃ©pare la **correction directe** aprÃ¨s que tu mâ€™envoies tes rÃ©ponses, comme on fait dâ€™habitude ?

